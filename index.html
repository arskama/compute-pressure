
<!DOCTYPE html>
<meta charset="utf-8" />
<title>Compute Pressure API</title>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
<script class="remove">
  // All config options at https://respec.org/docs/
  const respecConfig = {
    shortName: "compute-pressure",
    group: "wicg",
    specStatus: "CG-DRAFT",
    xref: "web-platform",
    github: "https://github.com/wicg/compute-pressure",
    formerEditors: [
      {
        name: "Olivier Yiptong",
        company: "Google Inc.",
        companyURL: "https://google.com",
      }
    ],
    editors: [
      {
        name: "Kenneth Rohde Christiansen",
        company: "Intel Corporation",
        companyURL: "https://intel.com",
        w3cid: 57705,
      },
      {
        name: "Arnaud Mandy",
        company: "Intel Corporation",
        companyURL: "https://intel.com",
        w3cid: 126342,
      },
      {
        name: "Victor Costan",
        company: "Google Inc.",
        companyURL: "https://google.com",
      }
    ],
    testSuiteURI: "https://github.com/web-platform-tests/wpt/labels/compute-pressure",
    xref: {
      profile: "web-platform",
      specs: [
        "permissions", "hr-time"
      ]
    }
  };
</script>
<section id="abstract">
  <p>
    The <cite>Compute Pressure API</cite> provides a way for websites to react to changes
    in the CPU consumption of the target device, such that websites can trade off
    resources for an improved user experience.
  </p>
</section>
<section id="sotd"></section>
<section class="informative">
  <h2>Introduction</h2>
  <p>
    Modern applications often need to balance the trade offs and advantages of fully utilizing
    the system's computing resources, in order to provide a modern and delightful user experience.
  </p>
  <p>
    As an example, many applications can render video effects with varying degrees of sophistication.
    These applications aim to provide the best user experience, while avoiding driving the user's
    device into a high pressure regime.
  </p>
  <p>
    Utilization of [=processing units=] close to and often reaching 100% can lead to a bad
    user experience, as different tasks are fighting for the processing time.
    This can lead to slowless, which is especially noticeable with input delay.

    Further, a prolonged utilization close 100% can cause the [=processing units=] to heat up due to prolonged
    boosting, which can lead to throttling, resulting in an even worse user experience.
  </p>
  <p>
    As a result of thermal limits, many smartphones, tablets and laptops can become uncomfortably hot
    to the touch. The fans in laptops and desktops can become so loud that they disrupt conversations
    or the users’ ability to focus.
  </p>
  <p>
    In many cases, a device under high pressure appears to be unresponsive, as the operating
    system may fail to schedule the threads advancing the task that the user is waiting for. See also
    <a href="https://github.com/wicg/compute-pressure/#goals--motivating-use-cases">Compute Pressure:
    Use Cases</a>.
  </p>
</section>
<section>
  <h2>A Note on Feature Detection</h2>
  <p><i>This section is non-normative.</i></p>
  <p>
    Feature detection is an established web development best practice. Resources on the topic are plentiful on- and
    offline and the purpose of this section is not to discuss it further, but rather to put it in the context of
    detecting hardware-dependent features.
  </p>
  <p>
    Consider the below feature detection examples:
  </p>
  <aside class="example" title="Checking existence of ComputePressureObserver interface">
    <p>
      This simple example illustrates how to check whether the [=User Agent=] exposes the
      {{ComputePressureObserver}} interface
    </p>
    <pre class="js">
      if ("ComputePressureObserver" in globalThis) {
        // Use ComputePressureObserver interface
      }
    </pre>
  </aside>
  <aside class="note">
    <p>
      Checking against {{globalThis/globalThis}} will work on any [=ECMAScript/agent=] as defined by
      [[ECMAScript]], thus also in workers.
    </p>
    <p>
      It does however not tell you whether that API is actually connected to a
      real [=platform collector=], whether the [=platform collector=] is collecting real telemetry
      readings, or whether the user is going to allow you to access it.
    </p>
  </aside>
</section>
<section>
  <h2>Concepts</h2>
  <p>
    This specification defines the following concepts:
  </p>
  <section>
    <h3><dfn>Processing Units</dfn></h3>
    <p>
      Computing devices consist of a multitude of different processing units such as the Central
      Processing Unit (CPU), the Graphics Processing Unit (GPU) and many specialized
      processing units. The latter are becoming popular such as ones designed to accelerate specific
      tasks like machine learning or computer vision.
    </p>
  </section>
  <section>
    <h3>Sampling and Reporting Frequency</h3>
    <p>
      The <dfn>sampling frequency</dfn> for a [=platform collector=] is defined as a frequency
      at which the [=user agent=] obtains telemetry readings from the underlying platform.
    </p>
    <p>
      The [=sampling frequency=] is equal to the [=requested sampling frequency=] if the [=user agent=]
      can support it.
    </p>
    <p>
      The [=sampling frequency=] differs from the [=requested sampling frequency=] in the following cases:
      <ul>
        <li>
          The [=requested sampling frequency=] exceeds upper or lower sampling frequency bounds
          supported or accepted by the underlying platform and [=user agent=]<sup>†</sup>.
        </li>
      </ul>
      <p>
        <sup>†</sup>It is recommended that the [=user agent=] limits the [=reporting frequency=]
        as outlined in [[[#rate-limiting-change-notifications]]].
      </p>
    </p>
    <p>
      The <dfn>reporting frequency</dfn> is the rate at which the {{ComputePressureUpdateCallback}}
      will be queued as a [=task=] on the [=ComputePressureObserver task source=] in case there
      is data to report.
    </p>
    <p>
      The [=reporting frequency=] is not allowed to exceed the [=sampling frequency=].
    </p>
    <p>
      In case the user didn't request a [=sampling frequency=], the [=sampling frequency=]
      is [=implementation-defined=].
    </p>
    <aside class="note">
      In case there are multiple instances of {{ComputePressureObserver}} active with different
      [=sampling frequencies=], it is up to the [=user agent=] to set a [=platform collector=]
      level [=sampling frequency=] that best fulfills these requests, while
      making sure that the [=reporting frequency=] of all {{ComputePressureObserver}}s does
      not exceed their respective [=requested sampling frequencies=].
    </aside>
  </section>
</section>

<section> <h2>Platform primitives</h2>
  <p>
    The term <dfn>platform collector</dfn> refers to platform interface, with which the [=user agent=] interacts to
    obtain the telemetry readings required by this specification.
  </p>
  <p>
    A [=platform collector=] can be defined by the underlying platform (e.g. in a native telemetry
    framework) or by the [=user agent=], if it has a direct access to hardware counters.
  </p>
  <p>
    A [=platform collector=] can support telemetry for different <dfn>source types</dfn> of computing
    devices defined by {{ComputePressureSource}}, or there can be multiple [=platform collectors=].
  </p>
  <p>
    From the implementation perspective [=platform collector=] can be treated as a software proxy for the
    corresponding hardware counters. It is possible to have multiple [=platform collector=] simultaneously
    interacting with the same underlying hardware if the underlying platform supports it.
  </p>
  <p>
    In simple cases, a [=platform collector=] represents individual hardware counters, but if the provided
    counter readings are a product of data fusion performed in software, the [=platform collector=]
    represents the results of the data fusion process. This may happen in user space or in kernel space.
  </p>
  <p>
    As collecting telemetry data often means polling hardware counters, it is not a free operation and thus,
    it should not happen if there are no one observing the data. See [[[#life-cycle]]] for more information.
  </p>
  <p>
    A [=platform collector=] samples data at a specific frequency. A [=user agent=] may modify this frequency
    (if possible) for privacy reasons, or ignore and fuse certain readings.
  </p>
</section>

<section>
  <h3>
    Permissions and user prompts
  </h3>
  <p>
    The [[[PERMISSIONS]]] API provides a uniform way for websites to request
    permissions from users and query which permissions they have.
  </p>
  <p>
    A <a>user agent</a> can per [=origin=] deny observation of a
    particular compute pressure [=source type=] by any
    [=implementation-defined=] reason, such as platform setting or user
    preference.
  </p>
  <p>
    It is RECOMMENDED that a [=user agent=] show some form of unobtrusive
    notification that informs the user when a compute pressure observer is active,
    as well as provides the user with the means to block the ongoing operation,
    or simply dismiss the notification.
  </p>
  <section>
    <h3>
      Permissions integration
    </h3>
    <p>
      The Compute Pressure API is a [=powerful feature=] which is identified
      by the name "`compute-pressure`".
    </p>
  </section>
</section>

<section>
  <h3>
    Internal Slot Definitions
  </h3>
  <p>
    Each [=similar-origin window agent=], [=dedicated worker agent=] and [=shared worker agent=]
    has:
    <ul>
      <li>
        a <dfn>compute pressure observer task queued</dfn> (a boolean), which is initially false.
      </li>
      <li>
        a <dfn>registered observer list</dfn> per supported [=source type=], which is initially empty.
      </li>
    </ul>
    A <dfn>registered observer</dfn> consists of an <dfn>observer</dfn> (a {{ComputePressureObserver}} object).
  </p>
  <p>
    A constructed  {{ComputePressureObserver}} object has the following internal slots:
  </p>
  <ul data-dfn-for="ComputePressureObserver">
    <li>
      a <dfn>[[\Callback]]</dfn> of type {{ComputePressureUpdateCallback}} set on creation.
    </li>
    <li>
      a <dfn>[[\Options]]</dfn> of type {{ComputePressureObserverOptions}} set on creation.
    </li>
    <li>
      a <dfn>[[\QueuedRecords]]</dfn> [=queue=] of zero or more {{ComputePressureRecord}}
      objects, which is initially empty.
    </li>
    <li>
      a <dfn>[[\LastRecordMap]]</dfn> [=ordered map=], [=map/keyed=] on a {{ComputePressureSource}},
      representing the [=source type=] to which the last record belongs.
      The [=ordered map=]'s [=map/value=] is a {{ComputePressureRecord}}.
    </li>
  </ul>
  <p>
    The [=user agent=] additionally has a <dfn>max queued records</dfn> integer, which
    is set to an [=implementation-defined=] value, greater than 0.
    </li>
  </p>
</section>

<section> <h2>Pressure States</h2>
  <p>
    <dfn>Pressure states</dfn> represents the minimal set of useful states that allows websites
    to react to changes in compute pressure with minimal degration in quality or service, or user
    experience.
  </p>
  <pre class="idl">
    enum ComputePressureState { "nominal", "fair", "serious", "critical" };
  </pre>
  <p>
    The <dfn>ComputePressureState</dfn> enum represents the [=pressure state=] with the following states:
  </p>
  <p>
    <style>
      @counter-style pressure-states-emoji {
        system: cyclic;
        symbols: "⚪" "🟢" "🟡" "🔴";
        suffix: " ";
      }
      .pressure-states {
        list-style-type: pressure-states-emoji;
      }
    </style>
    <ul class="pressure-states">
      <li>
        <b>Nominal</b>: Current workloads are causing minimal pressure, allowing the system to run
        at a lower clock frequency to preserve power.
      </li>
      <li>
        <b>Fair</b>: The system is doing fine, everything is smooth and it can take on additional work without issues.
      </li>
      <li>
        <b>Serious</b>: There is some serious pressure on the system, but it is sustainable and the system
        is doing well, but it is getting close to its limits:
        <ul>
          <li>
            Clock speed (depending on AC or DC power) is consistently high
          </li>
          <li>
            Thermals are high but system can handle it
          </li>
        </ul>
        At this point, if you add more work the system may move into critical.
      </li>
      <li>
        <b>Critical</b>: The system is now about to reach its limits, but it hasn’t reached <em>the</em> limit yet.
        Critical doesn’t mean that the system is being actively throttled, but this state is not sustainable for
        the long run and might result in throttling if the workload remains the same. This signal is the last call
        for the web application to lighten its workload.
      </li>
    </ul>
  </p>
</section>

<section> <h2>Pressure Factors</h2>
  <p>
    <dfn>Pressure factors</dfn> represents factors affecting system performance and current [=pressure state=].
    In case the [=pressure state=] is nominal, the {{ComputePressureRecord.factors}} will always an [=list/empty=]
    sequence.
  </p>
  <aside class="note">
    The [=user agent=] might not be able to expose the factors for all systems or for all [=pressure states=].
  </aside>
  <style>
    @counter-style pressure-factors-emoji {
      system: cyclic;
      symbols: "🌡" "🔌";
      suffix: " ";
    }
    .pressure-factors {
      list-style-type: pressure-factors-emoji;
    }
  </style>
  <pre class="idl">
    enum ComputePressureFactor { "thermal", "power-supply" };
  </pre>
  <p>
    The <dfn>ComputePressureFactor</dfn> enum represents the [=pressure factors=]:
  </p>
  <p>
    <ul class="pressure-factors">
      <li>
        <b>Thermal</b>: The source is under elevated thermal conditions and the system is
        unable to keep temperature below safe limits at peak power.
      </li>
      <li>
        <b>Power</b>: The power supply (incl. battery capacity) is too weak to run at peak power,
        or artificially limited by a system or user initiated power mode to conserve power or
        avoid fan noise.
      </li>
    </ul>
  </p>
</section>

<section> <h2>Compute Pressure Observer</h2>
The Compute Pressure Observer API enables developers to understand the utilization characteristics of a CPU.

<section data-dfn-for="ComputePressureObserverCallback">
  <h3>The <a>ComputePressureUpdateCallback</a> callback</h3>
  <pre class="idl">
    callback ComputePressureUpdateCallback = undefined (
      sequence&lt;ComputePressureRecord&gt; changes,
      ComputePressureObserver observer
    );
  </pre>
  This callback will be invoked when the [=pressure state=] changes.
</section>

<section  data-dfn-for="ComputePressureObserver"> <h2>The <a>ComputePressureObserver</a> object</h2>
  <p>
    The {{ComputePressureObserver}} can be used to observe changes in the [=pressure states=].
  </p>
  <pre class="idl">
    enum ComputePressureSource { "cpu" };

    [Exposed=(DedicatedWorker,SharedWorker,Window), SecureContext]
    interface ComputePressureObserver {
      constructor(ComputePressureUpdateCallback callback, optional ComputePressureObserverOptions options = {});

      undefined observe(ComputePressureSource source);
      undefined unobserve(ComputePressureSource source);
      undefined disconnect();
      sequence&lt;ComputePressureRecord&gt; takeRecords();

      [SameObject] static readonly attribute FrozenArray&lt;ComputePressureSource&gt; supportedSources;

      [Exposed=Window] static Promise&lt;PermissionState&gt; requestPermission();
    };
  </pre>

  <p>The <dfn>ComputePressureObserver</dfn> interface represents a {{ComputePressureObserver}}.</p>

  <section>
    <h3>The <dfn>constructor()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/constructor()}} method, when invoked, MUST run the
      following step, given the arguments |callback:ComputePressureUpdateCallback|
      and |options:ComputePressureObserverOptions|:
      <ol class="algorithm">
        <li>
          Let |this:ComputePressureObserver| be a new the {{ComputePressureObserver}} object.
        </li>
        <li>
          Set |this|.{{ComputePressureObserver/[[Options]]}} to |options|.
        </li>
        <li>
          Set |this|.{{ComputePressureObserver/[[Callback]]}} to |callback|.
        </li>
        <li>
          Return |this|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>observe()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/observe()}} method, when invoked, MUST run the
      following step, given the arguments |source:ComputePressureSource|:
      <ol class="algorithm">
        <li>
          Let |permissionState:PermissionState| be the result of
          [=getting the current permission state=] with "`compute-pressure`".
        </li>
        <li>
          If |permissionState| is not [=permission/granted=], throw {{NotAllowedError}}.
        </li>
        <li>
          If |source| is not a supported [=source type=], throw {{"TypeError"}}.
        </li>
        <li>
          If [=registered observer list=] for |source| is empty, activate the underlying
          [=platform collector=] for |source|.
        </li>
        <li>
          [=list/Append=] a new [=registered observer=] whose [=observer=] is [=this=]
          to [=registered observer list=] for |source|.
        </li>
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>unobserve()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/unobserve()}} method, when invoked, MUST run the
      following step, given the arguments |source:ComputePressureSource|:
      <ol class="algorithm">
        <li>
          If |source| is not a supported [=source type=], throw {{"TypeError"}}.
        </li>
        <li>
          [=list/Remove=] from |this|.{{ComputePressureObserver/[[QueuedRecords]]}} all
          |records| associated with |source|.
        </li>
        <li>
          [=map/Remove=] |this|.{{ComputePressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          Remove any [=registered observer=] from [=registered observer list=] for
          |source| for which [=this=] is the [=registered observer=].
        </li>
        <li>
          If the above [=registered observer list=] becomes [=list/empty=], deactivate the
          underlying [=platform collector=] for the associated |source|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>disconnect()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/disconnect()}} method, when invoked, MUST run the
      following step:
      <ol class="algorithm">
        <li>
          [=list/Empty=] |observer|.{{ComputePressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          [=map/Clear=] |this|.{{ComputePressureObserver/[[LastRecordMap]]}}.
        </li>
        <li>
          Remove any [=registered observer=] from [=registered observer list=] for
          all supported [=source types=] for which [=this=] is the [=observer=].
        </li>
        <li>
          If any [=registered observer list=] becomes [=list/empty=], deactivate the
          underlying [=platform collector=] for the associated |source|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>takeRecords()</dfn> method</h3>
    <aside class="note">
      <p>
        A common use case for this is to immediately fetch all pending state change records
        immediately prior to disconnecting the observer, so that any pending state changes
        can be processed when shutting down the observer.
      </p>
      <p>
        Another use case is the ability to receive any pending, already-generated states
        changes without waiting for the callbacks to be invoked. Callbacks are invoked from
        a task queue as part of the event loop cycle, so this allows for conferring the
        current state outside of the event loop cycle.
      </p>
    </aside>
    <p>
      The {{ComputePressureObserver/takeRecords()}} method, when invoked, MUST run the
      following step:
      <ol class="algorithm">
        <li>
          Let |records| be a [=list/clone=] of |observer|.{{ComputePressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          [=list/Empty=] |observer|.{{ComputePressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          Return |records|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>supportedSources</dfn> attribute</h3>
    <p>
      The {{ComputePressureObserver/supportedSources}} attribute is informing on the supported source by the [=platform collector=].
      When {{ComputePressureObserver/supportedSources}}'s attribute getter is called, MUST run the following steps:
      <ol class="algorithm">
        <li>
          Let |sources| be a [=list=] of |source:ComputePressureSource|.
        </li>
        <li>
          Return |observer|'s frozen array of supported [=source types=].
        </li>
      </ol>
    </p>
    <aside class="note">
      <p>
        This attribute allows web developers to easily know which [=source types=] are supported by the user agent.
      </p>
    </aside>
  </section>
  <section>
    <h3>The static <dfn>requestPermission()</dfn> method</h3>
    <p>
      The {{ComputePressureObserver/requestPermission()}} method, when invoked, MUST run the
      following step:
      <ol class="algorithm">
        <li>
          If the [=relevant global object=] of [=this=] does not have [=transient activation=],
          return [=a new promise=] [=rejected=] with a {{NotAllowedError}}.
        </li>
        <li>
          Let |result:Promise| be [=a new promise=].
        </li>
        <li>
          Run these steps [=in parallel=]:
          <ol>
            <li>
              Let |permissionState:PermissionState| be the result of
              [=requesting permission to use=] the [=powerful feature=] named "`compute-pressure`".
            </li>
            <li>
              [=Queue a global task=] on the [=relevant global object=] of [=this=] using
              the [=permissions task source=] to [=resolve=] |result| with |permissionState|.
            </li>
          </ol>
        </li>
        <li>
          Return |result|.
        </li>
      </ol>
    </p>
  </section>
</section>

<section data-dfn-for="ComputePressureRecord">
  <h3>The <dfn>ComputePressureRecord</dfn> dictionary</h3>
  <pre class="idl">
    dictionary ComputePressureRecord {
      ComputePressureSource source;
      ComputePressureState state;
      sequence&lt;ComputePressureFactor&gt; factors;
      DOMHighResTimeStamp timestamp;
    };
  </pre>
  <section>
    <h3>The <dfn>source</dfn> attribute</h3>
    <p>
      The {{ComputePressureRecord/source}} attribute represents the current [=source type=].
    </p>
  </section>
  <section>
    <h3>The <dfn>state</dfn> attribute</h3>
    <p>
      The {{ComputePressureRecord/state}} attribute represents the current [=pressure state=].
    </p>
  </section>
  <section>
    <h3>The <dfn>factors</dfn> attribute</h3>
    <p>
      The {{ComputePressureRecord/factor}} attribute represents a [=sequence=] of the current [=pressure factors=].
    </p>
  </section>
  <section>
    <h3>The <dfn>timestamp</dfn> attribute</h3>
    <p>
      The {{ComputePressureRecord/timestamp}} attribute represents timestamp when the date was obtained from the system.
    </p>
  </section>
</section>

<section data-dfn-for="ComputePressureObserverOptions">
  <h3>The <dfn>ComputePressureObserverOptions</dfn> dictionary</h3>
  <pre class="idl">
    dictionary ComputePressureObserverOptions {
      double frequency;
    };
  </pre>
  <section>
    <h3>The <dfn>frequency</dfn> member</h3>
    <p>
      The {{ComputePressureObserverOptions/frequency}} member represents the <dfn>requested sampling
      frequency</dfn> in hertz.
    </p>
    <aside class="note">
      <p>
        For slow reporting frequency (less than 1hz), it is common to use seconds and talk about
        period instead of frequency. Fortunately, it is easy to convert between the two, as hertz
        is rotations per second. If you want to request a sampling frequency of 10 seconds, then
        just use the value of 0.1.
      </p>
      <p>
        A [=user agent=] might not be able to respect the requested frequency. For more information
        consult [[[#sampling-and-reporting-frequency]]].
      </p>
    </aside>
  </section>
</section>

<section id="life-cycle">
  <h3>Life-cycle and garbage collection</h3>
  <p>
    The <a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agents</a> have a
    strong reference to [=registered observers=] in their [=registered observer list=]
    (one per source).
  </p>
  <aside class="note">
    <p>
      A {{ComputePressureObserver}} is observing a |source:ComputePressureSource| if it
      exists in the [=registered observer list=], modified by invocations of
      {{ComputePressureObserver/observe()}},
      {{ComputePressureObserver/unobserve()}}
      and {{ComputePressureObserver/disconnect()}}.
    </p>
    <p>
      This means that {{ComputePressureObserver}} |observer:ComputePressureObserver| will
      remain alive until both of these conditions hold:
      <ul>
        <li>
          There are no scripting references to the |observer|.
        </li>
        <li>
          The |observer| is not observing any |source|.
        </li>
      </ul>
    </p>
    <p>
      [[[#cb-observer-example]]] contains an example of how to use the
      {{ComputePressureObserver/disconnect()}} (or any other {{ComputePressureObserver}}
      method) from the observer callback.
    </p>
  </aside>
</section>

<section id="processing-model">
  <h3>Processing Model</h3>
  <p>
    This section outlines the steps the user agent must take when implementing the Compute Pressure Observer API.
  </p>
  <section>
    <h3>Supporting algorithms</h3>
    <p>
      <aside class="note">
        Readings are available for [=documents=] (incl. [=iframes=] and popup windows),
        matching the following criteria:
        <ul>
          <li>
            They are [=Document/fully active=] [=documents=].
          </li>
          <li>
            Their [=origin=] is [=same origin-domain=] with the
            <a href="https://html.spec.whatwg.org/multipage/interaction.html#currently-focused-area-of-a-top-level-browsing-context">
            currently focused area</a> document.
          </li>
        </ul>
        Reading are available for workers matching the following critetia:
        <ul>
          <li>
            They are <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">active needed workers</a>.
          </li>
          <li>
            Their [=origin=] is [=same origin-domain=] with the
            <a href="https://html.spec.whatwg.org/multipage/interaction.html#currently-focused-area-of-a-top-level-browsing-context">
            currently focused area</a> document.
          </li>
        </ul>
      </aside>
      The <dfn>passes privacy test</dfn> steps given the argument |observer:ComputePressureObserver|, are as follows:
      <ol>
        <li>
          Let |o| be |observer|'s [=relevant global object=].
        </li>
        <li>
          If |o| is a {{Window}} object:
          <ol>
            <li>
              If |o|'s [=associated document=] is not [=Document/fully active=], return false.
            </li>
          </ol>
        </li>
        <li>
          If |o| is a {{WorkerGlobalScope}} object:
          <ol>
            <li>
              If |o|'s relevant worker is not a <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
              active needed worker</a>, return false.
            </li>
          </ol>
        <li>
          If |o|'s [=relevant settings object=]'s [=origin=] is [=same origin-domain=] with
          <a href="https://html.spec.whatwg.org/multipage/interaction.html#currently-focused-area-of-a-top-level-browsing-context">
            currently focused area</a>'s [=origin=], return true.
        </li>
        </li>
        <li>
          Otherwise, return false.
        </li>
      </ol>
      <aside class="note">
        As there might be multiple observers, each with a different [=requested sampling frequency=], the underlying
        [=platform collector=] will need to use a [=sampling frequency=] that fulfills all these requirements. This also
        means that not every data sample from the [=platform collector=] needs to be delivered to each active
        observer.
      </aside>
      The <dfn>passes frequency test</dfn> steps given the argument |observer:ComputePressureObserver|,
      |source:ComputePressureSource| and |timestamp:DOMHighResTimeStamp|, are as follows:
      <ol>
        <li>
          If |observer|.{{ComputePressureObserver/[[LastRecordMap]]}}[|source|] does not [=map/exist=], return true.
        </li>
        <li>
          Let |record:ComputePressureRecord| be |observer|.{{ComputePressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          Let |frequency| be |observer|.{{ComputePressureObserver/[[Options]]}}.{{ComputePressureObserverOptions/frequency}}.
        </li>
        <li>
          Let |timeDelta:DOMHighResTimeStamp| = |record|.{{ComputePressureRecord/timestamp}} - |timestamp|.
        </li>
        <li>
          If |timeDelta| &gt; (1 / |frequency|), return true, otherwise return false.
        </li>
      </ol>
      The <dfn>has change in data</dfn> steps given the argument |observer:ComputePressureObserver|,
      |state:ComputePressureState| and |factors:sequence&lt;ComputePressureFactor&gt;|, are as follows:
      <ol>
        <li>
          If |observer|.{{ComputePressureObserver/[[LastRecordMap]]}}[|source|] does not [=map/exist=], return true.
        </li>
        <li>
          Let |record:ComputePressureRecord| be |observer|.{{ComputePressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          If |record|.{{ComputePressureRecord/state}} is not equal to |state|, return false.
        </li>
        <li>
          If |record|.{{ComputePressureRecord/factors}} and |factors| does not [=list/contain=] the same [=list/items=],
          return false.
        </li>
        <li>
          Return true.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>Respond to new platform collector readings</h3>
    <p>
      When a [=implementation-defined=] |data| sample of [=source type=] |source:ComputePressureSource| is
      obtained from the [=platform collector=], the [=user agent=] MUST run these steps:
      <ol>
        <li>
          Let |source:ComputePressureSource| be the [=source type=] of the |data| sample.
        </li>
        <li>
          Let |state:ComputePressureState| be an [=implementation-defined=] state given
          |data| and |source|.
        </li>
        <li>
          Let |factors:sequence&lt;ComputePressureFactor&gt;| be an [=implementation-defined=]
          [=sequence=] given |data| and |source|, potentially [=list/empty=].
        </li>
        <li>
          Let |timestamp:DOMHighResTimeStamp| be a timestamp representing the time the |data| was
          obtained from the [=platform collector=].
        </li>
        <aside class="note">
          The |data| sample and mapping between |data| sample, and [=pressure states=]
          and [=pressure factors=] contributing to the current state,
          is [=implementation-defined=] and may use many different metrics. For instance,
          for CPU, it might consider processor frequency and utilization, as well
          as thermal conditions.
        </aside>
        <li>
          If |state| has not changed since last sample for |source|, abort these steps.
        </li>
        <li>
          [=list/For each=] |observer:ComputePressureObserver| in the [=registered observer list=] for |source|:
          <ol>
            <li>
              If running [=passes privacy test=] with |observer|
              returns false, [=iteration/continue=].
            </li>
            <li>
              If running [=passes frequency test=] with |observer|, |source| and |timestamp|
              returns false, [=iteration/continue=].
            </li>
            <li>
              If running [=has change in data=] with |observer|, |state| and |factors|
              returns false, [=iteration/continue=].
            </li>
            <li>
              Run [=queue a record=] with |observer|, |source|, |state|, |factors| and |timestamp|.
            </li>
          </ol>
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>Queue a ComputePressureRecord</h3>
    <p>
      To <dfn>queue a record</dfn> given the arguments |observer:ComputePressureObserver|,
      |source:ComputePressureSource|, |state:ComputePressureState|,
      |factors:sequence&lt;ComputePressureFactor&gt;| and |timestamp:DOMHighResTimeStamp|,
      run these steps:
    </p>
    <ol class="algorithm">
      <li>
        Let |record:ComputePressureRecord| be the result of running [=create a record=] with
        |source|, |state|, |factors| and |timestamp|.
      </li>
      <li>
        If [=list/size=] of |observer|.{{ComputePressureObserver/[[QueuedRecords]]}} is greater than
        [=max queued records=], then [=list/remove=] the first [=list/item=].
      <li>
        [=list/Append=] |record| to |observer|.{{ComputePressureObserver/[[QueuedRecords]]}}.
      </li>
      <li>
        Set |observer|.{{ComputePressureObserver/[[LastRecordMap]]}}[|source|] to |record|.
      </li>
      <li>
        [=Queue a compute pressure observer task=].
      </li>
    </ol>
  </section>
  <section id="create-record">
    <h3>Create and populate a ComputePressureRecord</h3>
    <p>
      To <dfn>create a record</dfn> given the arguments |source:ComputePressureSource|,
      |state:ComputePressureState|, |factors:sequence&lt;ComputePressureFactor&gt;|
      and |timestamp:DOMHighResTimeStamp|, run these steps:
    </p>
    <ol class="algorithm">
      <li>
        Let |record:ComputePressureRecord| be a new {{ComputePressureRecord}} instance.
      </li>
      <li>
        Set |record|.|source:ComputePressureSource| to |source|.
      </li>
      <li>
        Set |record|.|state:ComputePressureState| be |state|.
      </li>
      <li>
        Set |record|.|factors:sequence&lt;ComputePressureFactor&gt;| be |factors|.
      </li>
      <li>
        Set |record|.|timestamp:DOMHighResTimeStamp| be |timestamp|.
      </li>
      <li>
        Return |record|.
      </li>
    </ol>
  </section>
  <section>
    <h3>Queue a ComputePressureObserver Task</h3>
    <p>
      The <dfn>ComputePressureObserver task source</dfn> is a [=task source=] used for scheduling tasks to [[[#notify-observers]]].
    </p>
    <p>
      To <dfn>queue a compute pressure observer task</dfn> run these steps:
    </p>
    <ol class="algorithm">
      <li>
        If the <a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a>'s [=compute pressure observer task queued=] is true, then return.
      </li>
      <li>
        Set the <a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a>'s [=compute pressure observer task queued=] to true.
      </li>
      <li>
        [=Queue=] a [=task=] on the [=ComputePressureObserver task source=] to [[[#notify-observers]]].
      </li>
    </ol>
  </section>
  <section id="notify-observers">
    <h3>Notify Compute Pressure Observers</h3>
    <ol class="algorithm">
      <li>
        Set the <a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a>'s [=compute pressure observer task queued=] to false.
      </li>
      <li>
        Let |notifySet| be a new [=set=] of all [=observers=] in
        <a href="https://tc39.es/ecma262/#surrounding-agent">surrounding agent</a>’s
        [=registered observer lists=].
      </li>
      <li>
        [=list/For each=] |observer:ComputePressureObserver| of |notifySet|:
        <ol>
          <li>
            Let |records| be a [=list/clone=] of |observer|.{{ComputePressureObserver/[[QueuedRecords]]}}.
          </li>
          <li>
            [=list/Empty=] |observer|.{{ComputePressureObserver/[[QueuedRecords]]}}.
          </li>
          <li>
            If |records| is not [=list/empty=], then invoke |observer|.{{ComputePressureObserver/[[Callback]]}}
            with |records| and |observer|. If this throws an exception, catch it, and [=report the exception=].
          </li>
        </ol>
      </li>
    </ol>
  </section>
</section>

<section>
  <h2>
    Security and privacy considerations
  </h2>
  <p>
    Please consult the <a href="security-privacy-self-assessment.md">Security and Privacy Self-Assessment</a>
    based upon the [[[security-privacy-questionnaire]]].
  </p>
  <section>
    <h3>Minimizing information exposure</h3>
    <p>
      Exposing hardware related events related to low -level details such as exact CPU
      utilization or frequency
      <a href="https://w3ctag.github.io/design-principles/#device-ids">
      increases the risk of harming the user's privacy</a>.
    </p>
    <p>
      To mitigate this risk, no such low level details are exposed.
    </p>
    <p>
      The subsections below describe the processing model. At a high level, the
      information exposed is reduced by the following steps:
      <ol>
        <li>
          <b>Rate-limiting</b> - The user agent notifies the application of changes in
          the information it can learn. Change notifications are rate-limited.
        </li>
        <li>
          <b>first-party context</b> - The feature is only available in first-party
          contexts.
        </li>
      </ol>
      <section>
        <h4>Rate-limiting change notifications</h4>
        <p>
          We propose exposing the pressure state via
          rate-limited change notifications. This aims to remove the ability to observe
          the precise time when a value transitions between two states.
        </p>
        <p>
          More precisely, once the compute pressure observer is activated, it will be
          called once with initial values, and then be called when the values change.
          The subsequent calls will be rate-limited. When the callback is
          called, the most recent value is reported.
        </p>
        <p>
          The specification will recommend a rate limit of at most one call per second
          for the active window, and one call per 10 seconds for all other windows. We
          will also recommend that the call timings are jittered across origins.
        </p>
        <p>
          These measures benefit the user's privacy, by reducing the risk of
          identifying a device across multiple origins. The rate-limiting also benefits
          the user's security, by making it difficult to use this API for timing attacks.
          Last, rate-limiting change callbacks places an upper bound on the performance
          overhead of this API.
        </p>
        <p>
          Rate limiting can be implemented in the user agent, but it might also be
          possible to simply change the polling frequency of the underlying hardware
          counters, if not accessed via a higher level framework.
        </p>
      </section>
      <section>
        <h4>No side-channels</h4>
        <p>
          It is possible to identify users across non-[=same origin=] sites if unique
          or very precise values can be accessed at the same time by sites not sharing
          origin.
        </p>
        <p>
          If the same [=pressure state=] and timestamp is observed by two origins, that
          would be a good indication that the origin is used by the same user on the
          same machine. For this reason, Compute Pressure API limits reporting [=pressure
          state=] changes to one origin at the time.
        </p>
        <p>
          A common way to do this, is only to report changes to the focused page, but
          one of the main users of this API are video conferencing sites. These sites
          want to make sure that the video streams and effects doesn't negatively affect
          the system and thus the conferencing experience - but there are two common
          cases where the site will usually not be focused:
          <ul>
            <li>
              The user is taking meeting notes and the site is in the background. Commonly
              the video stream is only visible via a picture-in-picture window.
            </li>
            <li>
              The user is sharing an external application window such as a presentation,
              or sharing the whole screen, unusually with some UI indicating sharing is
              happening.
            </li>
          </ul>
          For this reason, the Compute Pressure API considers these two cases to have
          higher priority than whether the site is focused.
        </p>
      </section>
      <section>
        <h4>First-party contexts</h4>
        <p>
          This API will only be available in frames served from the same origin as the
          top-level frame. This requirement is necessary for preserving the privacy
          benefits of the API's quantizing scheme.
        </p>
        <p>
          The same-origin requirement above implies that the API is only available in
          first-party contexts.
        </p>
      </section>
    </p>
  </section>
</section>
<section id="examples" class="informative">
  <h2>
    Examples
  </h2>
  <p>
    As Compute Pressure is considered a [=powerful feature=], it requires user permission in
    order to be used.
  </p>
  <p>
    You can check whether the user has already granted permission using the [[[Permissions]]]
    API, both from the [=browsing context/active window=] or from a worker.
  </p>
  <pre class="example js" title="How to check whether user has granted permission">
    const { state } = await navigator.permissions.query({
      name: "compute-pressure"
    });
    switch (state) {
      case "granted":
        startUsingComputePressure();
        break;
      case "prompt":
        showExplanationAndToogleToAllowComputePressure();
        break;
      case "denied":
        // Do nothing, user prefers not to use compute pressure.
        break;
    }
  </pre>
  <p>
    Asking for permission has to happen in the [=browsing context/active window=] and
    can not be done from a worker, but the permission state is per [=origin=] and thus
    shared across [=browsing contexts=] and workers which are [=same origin=].
  </p>
  <p>
    The below examples shows you how to ask for permission before using the feature.
  </p>
  <pre class="example js" title="How to ask for permission before use">
    function handleComputePressureChange(records) {
      // do something with records.
    }

    button.onclick = async () => {
      const state = await ComputePressureObserver.requestPermission();
      if (state === "granted") {
        const observer = new ComputePressureObserver(handleComputePressureChange);
        observer.observe("cpu");
      }
    }
  </pre>
  <aside class="example" title="How to use it in a worker with permission">
    <p>
      Compute pressure is handled in a worker `worker.js`:
    </p>
    <pre class="js">
      const observer = new ComputePressureObserver(records => {
        // do something with records.
      });

      self.onmessage = event => {
        let { command } = event.data;

        if (command === "observe") {
          observer.observe("cpu");
        }
        if (command === "unobserve") {
          observer.unobserve("cpu");
        }
      }
    </pre>
    <p>
      And permission and worker instantiation is handled from the main [=browsing context=]:
    </p>
    <pre class="js">
      let worker;
      checkbox.onchange = event => {
        if (event.target.checked) {
          worker ??= new Worker('/worker.js'); // Create worker if it doesn't exist.
          worker.postMessage('observe');
        } else if (worker) {
          worker.postMessage('unobserve');
        }
      }
    </pre>
  </aside>
  <p>
    The callback is called with the observer it is invoked from. That allows to unobserve when
    certain conditions are met, or even to differenciate depending on who invoked it, if invoked
    by multiple observers or externally, say by `setTimeout()`.
  </p>
  <pre class="example js" title="How to access observer from callback" id="cb-observer-example">
    const samples = [];

    function pressureChange(records, observer) {
      for (const record of records) {
        samples.push(record.state);

        // We only want 20 samples.
        if (samples.length == 20) {
          observer.disconnect();
          return;
        }
      }
    }

    const observer = new ComputePressureObserver(pressureChange);
    observer.observe("cpu");
  </pre>
  <p>
    In the following example we want to lower the number of concurrent video streams when the
    compute pressure becomes critical. For the sake of simplicity we only consider this one state.
  </p>
  <p>
    As lowering the amount of streams might not result in exiting the critical state,
    or at least not immediately, we use a strategy where we lower one stream at the time
    every 30 seconds while still in the critical state.
  </p>
  <p>
    We accomplish this by making sure the callback is called at least once every 30 seconds,
    or when the state actually changes. When the state changes we reset the interval timer.
  </p>
  <pre class="example js" title="How to adjust the number of video feeds based on CPU pressure">
    let timerId = -1;
    function pressureChange(records) {
      // Clear timer every time we are called, either by an actual state change,
      // or when called by setTimeout (see below).
      if (timerId > 0) {
        clearTimeout(timerId);
      }

      // When entering critical state, we want to recheck every 30sec if we are
      // still in critical state and if so, further reduce our concurrent streams.
      // For this reason we create a timer for 30 seconds that will call us back
      // with the last result in there were no change.
      const lastRecordArray = [records.at(records.length - 1)];
      timerId = setTimeout(pressureChange.bind(this, lastRecordArray), 30_000);

      for (const record of records) {
        if (record.state == "critical") {
          let streamsCount = getStreamsCount();
          setStreamsCount(streamsCount--);
        }
      }
    }

    const observer = new ComputePressureObserver(pressureChange);
    observer.observe("cpu");
  </pre>
  <p>
    In the following example, we want to demonstrate the usage of {{ComputePressureObserver/takeRecords()}},
    by retrieving the remaining |records| accumulated since the the callback was last
    invoked.
  </p>
  <p>
    It is recommended to do so before {{ComputePressureObserver/disconnect()}},
    otherwise {{ComputePressureObserver/disconnect()}} will clear them and they will be lost forever.
  </p>
  <p>
    For example, we might want to measure the pressure during a benchmarking workload, and thus
    want pressure telemetry for the exact duration of the workload. This means disconnecting all
    observers immediately when the task is completed, and manually requesting any pending pressure
    telemetry up to this point that might not have been delivered yet as part of the event loop cycle.
  </p>
  <pre class="example js" title="How to handle all state changes right up until disconnect">
    function logWorkloadStatistics(records) {
      // do something with records.
    }

    const observer = new ComputePressureObserver(logWorkloadStatistics);
    observer.observe("cpu");

    // Read pending state change records, otherwise they will be cleared
    // when we disconnect.
    const records = observer.takeRecords();
    logWorkloadStatistics(records);

    observer.disconnect();
  </pre>
  <p>
    In the following example, we show how to tell the observer to stop watching a specific
    |source:ComputePressureSource| by invoking {{ComputePressureObserver/unobserve()}}
    with |source|.
  </p>
  <aside class="note">
    The example uses 'gpu', which could be a potential future addition to the specification. It aims to show
    that the API is extentable to support other types of compute pressure in the future
  </aside>
  <pre class="example js" title="How to tell the observer to stop watching for state changes for a specific source">
    const observer = new ComputePressureObserver(records => { // do something with records. }));

    observer.observe("cpu");
    observer.observe("gpu");

    // Callback now gets called whenever the pressure state changes for 'cpu' or 'gpu'.

    observer.unobserve("gpu");

    // Callback now only gets called whenever the pressure state changes for 'cpu'.
  </pre>
  <p>
    In the following example, we show how to tell the observer to stop watching for any
    state changes by calling {{ComputePressureObserver/disconnect()}}. Calling
    {{ComputePressureObserver/disconnect()}} will stop observing all sources observed
    by previous {{ComputePressureObserver/observe()}} calls.
  </p>
  <p>
    Additionally it will clear all pending records collected since the last callback was invoked.
  </p>
  <pre class="example js" title="how to tell the observer to stop watching for any state changes">
    const observer = new ComputePressureObserver(records => { // do something with records. });
    observer.observe("cpu");
    observer.observe("gpu");

    // some time later...

    observer.disconnect();

    // records will be an empty array, because of the previous disconnect().
    const records = observer.takeRecords();
  </pre>
</section>
<section id="conformance">
  <p>
    This specification defines conformance criteria for a single product: a
    <dfn>user agent</dfn> that implements the interfaces that it contains.
  </p>
</section>
<section class="appendix informative" id="acknowledgments"> <h2>Acknowledgments</h2>
  <p>
    Many thanks for valuable feedback and advice from
    Anssi Kostiainen,
    Arnaud Mandy,
    Asaf Yaffe,
    Chen Xing,
    Evan Shrubsole,
    François Beaufort,
    Jan Gora,
    Jesse Barnes,
    Joshua Bell,
    Kamila Hasanbega,
    Matt Menke,
    Moh Haghighat,
    Nicolás Peña Moreno,
    Opal Voravootivat,
    Paul Jensen,
    Peter Djeu,
    Raphael Kubo da Costa,
    Reilly Grant,
    Ulan Degenbaev,
    Victor Miura,
    and
    Zhenyao Mo
  </p>
</section>

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>
