<!DOCTYPE html>
<meta charset="utf-8" />
<title>Compute Pressure Level 1</title>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
<script class="remove">
  // All config options at https://respec.org/docs/
  const respecConfig = {
    shortName: "compute-pressure",
    group: "das",
    specStatus: "ED",
    xref: "web-platform",
    github: "https://github.com/w3c/compute-pressure",
    formerEditors: [
      {
        name: "Olivier Yiptong",
        company: "Google Inc.",
        companyURL: "https://google.com",
        w3cid: 81110,
      },
      {
        name: "Victor Costan",
        company: "Google Inc.",
        companyURL: "https://google.com",
        w3cid: 72312,
      }
    ],
    editors: [
      {
        name: "Kenneth Rohde Christiansen",
        company: "Intel Corporation",
        companyURL: "https://intel.com",
        w3cid: 57705,
      },
      {
        name: "Arnaud Mandy",
        company: "Intel Corporation",
        companyURL: "https://intel.com",
        w3cid: 126342,
      }
    ],
    testSuiteURI: "https://github.com/web-platform-tests/wpt/labels/compute-pressure",
    xref: {
      profile: "web-platform",
      specs: [
        "permissions-policy", "hr-time", "picture-in-picture", "mediacapture-streams"
      ]
    }
  };
</script>
<style>
  @counter-style pressure-states-emoji {
    system: cyclic;
    symbols: "\026AA" "\01F7E2" "\01F7E1" "\01F534";
    suffix: " ";
  }
  .pressure-states {
    list-style-type: pressure-states-emoji;
  }
  @counter-style pressure-source-emoji {
    system: cyclic;
    symbols: "\1F321" "\1F4A1";
    suffix: " ";
  }
  .pressure-source {
    list-style-type: pressure-source-emoji;
  }
  ul li::marker {
    font-family: "Segoe UI Emoji", "Noto Color Emoji";
  }
</style>
<section id="abstract">
  <p>
    The <cite>Compute Pressure API</cite> provides a way for websites to react to changes
    in the CPU pressure of the target device, such that websites can trade off
    resources for an improved user experience.
  </p>
</section>
<section id="sotd"></section>
<section class="informative">
  <h2>Introduction</h2>
  <p>
    Modern applications often need to balance the trade offs and advantages of fully utilizing
    the system's computing resources, in order to provide a modern and delightful user experience.
  </p>
  <p>
    As an example, many applications can render video effects with varying degrees of sophistication.
    These applications aim to provide the best user experience, while avoiding driving the user's
    device into a high pressure regime.
  </p>
  <p>
    Utilization of [=processing units=] close to and often reaching 100% can lead to a bad
    user experience, as different tasks are fighting for the processing time.
    This can lead to slowless, which is especially noticeable with input delay.

    Further, a prolonged utilization close 100% can cause the [=processing units=] to heat up due to prolonged
    boosting, which can lead to throttling, resulting in an even worse user experience.
  </p>
  <p>
    As a result of thermal limits, many smartphones, tablets and laptops can become uncomfortably hot
    to the touch. The fans in laptops and desktops can become so loud that they disrupt conversations
    or the users’ ability to focus.
  </p>
  <p>
    In many cases, a device under high pressure appears to be unresponsive, as the operating
    system may fail to schedule the threads advancing the task that the user is waiting for. See also
    <a href="https://github.com/wicg/compute-pressure/#goals--motivating-use-cases">Use Cases</a>.
  </p>
</section>
<section>
  <h2>A Note on Feature Detection</h2>
  <p><i>This section is non-normative.</i></p>
  <p>
    Feature detection is an established web development best practice. Resources on the topic are plentiful on- and
    offline and the purpose of this section is not to discuss it further, but rather to put it in the context of
    detecting hardware-dependent features.
  </p>
  <p>
    Consider the below feature detection examples:
  </p>
  <aside class="example" title="Checking existence of PressureObserver interface">
    <p>
      This simple example illustrates how to check whether the [=User Agent=] exposes the
      {{PressureObserver}} interface
    </p>
    <pre class="js">
      if ("PressureObserver" in globalThis) {
        // Use PressureObserver interface
      }
    </pre>
  </aside>
  <aside class="note">
    <p>
      Checking against {{globalThis/globalThis}} will work on any [=ECMAScript/agent=] as defined by
      [[ECMAScript]], thus also in workers.
    </p>
    <p>
      It does however not tell you whether that API is actually connected to a
      real [=platform collector=], whether the [=platform collector=] is collecting real telemetry
      readings, or whether the user is going to allow you to access it.
    </p>
  </aside>
</section>
<section>
  <h2>Concepts</h2>
  <p>
    This specification defines the following concepts:
  </p>
  <section>
    <h3>Processing Units</h3>
    <p>
      Computing devices consist of a multitude of different <dfn>processing units</dfn> such as the Central
      Processing Unit (CPU), the Graphics Processing Unit (GPU) and many specialized
      processing units. The latter are becoming popular such as ones designed to accelerate specific
      tasks like machine learning or computer vision.
    </p>
  </section>
  <section>
    <h3>Supported sources</h3>
    <p>
      The specification currently defines the <dfn>supported source types</dfn> as
      <em>global system thermals</em> and the <em>central [=processing unit=]</em>, also know as the CPU.
      Future levels of this specification MAY introduce additional [=source types=].
    </p>
    <pre class="idl">
      enum PressureSource { "thermals", "cpu" };
    </pre>
    <p>
      The <dfn>PressureSource</dfn> enum represents the [=supported source types=]:
    </p>
    <p>
      <ul class="pressure-source">
        <li>
          {{PressureSource/"thermals"}} represents the global thermal state of the system.
        </li>
        <li>
          {{PressureSource/"cpu"}} represents the average pressure of the central [=processing unit=]
          across all its cores.
        </li>
      </ul>
    </p>
    <aside class="note">
      <p>
        If a user calls {{PressureObserver/observe()}} with a [=source type=] not part of
        {{PressureSource}}, at the level of this specification the [=user agent=] supports,
        the method will throw a {{TypeError}}.
      </p>
      <p>
        If the [=source type=] is part of {{PressureSource}}, but not supported by the
        [=user agent=], host OS or underlying hardware, the method will instead throw
        {{NotSupportedError}}.
      </p>
      <p>
        To check what [=source types=] are supported, a user can call the static method
        {{PressureObserver/supportedSources()}}.
      </p>
    </aside>
  </section>
  <section>
    <h3>Sampling and Reporting Rate</h3>
    <p>
      The <dfn>sampling rate</dfn> for a [=platform collector=] is defined as a rate
      at which the [=user agent=] obtains telemetry readings from the underlying platform,
      and it might differ from the pressure observers' [=requested sampling rates=].
    </p>
    <p>
      The <dfn>reporting rate</dfn> for a pressure observer is the rate at which it runs
      the [=data delivery=] steps.
    </p>
    <p>
      The [=sampling rate=] differs from the [=requested sampling rate=] when the
      [=requested sampling rate=] exceeds upper or lower sampling rate bounds
      supported or accepted by the underlying platform and [=user agent=]<sup>†</sup>.
    </p>
    <p>
      <sup>†</sup>It is recommended that the [=user agent=] limits the [=reporting rate=]
      as outlined in [[[#rate-limiting-change-notifications]]].
    </p>
    <p>
      In case the user didn't request a [=sampling rate=], the [=sampling rate=]
      is [=implementation-defined=].
    </p>
    <aside class="note">
      In case there are multiple instances of {{PressureObserver}} active with different
      [=requested sampling rates=], it is up to the [=user agent=] to set a
      [=platform collector=] level [=sampling rate=] that best fulfills these requests,
      while making sure that the [=reporting rate=] of all {{PressureObserver}}s does
      not exceed their respective [=requested sampling rates=].
    </aside>
  </section>
</section>

<section> <h2>Platform primitives</h2>
  <p>
    The [=platform collector=] refers to a platform interface, with which the [=user agent=] interacts to
    obtain the telemetry readings required by this specification.
  </p>
  <p>
    A [=platform collector=] can be defined by the underlying platform (e.g. in a native telemetry
    framework) or by the [=user agent=], if it has a direct access to hardware counters.
  </p>
  <p>
    A [=platform collector=] can support telemetry for different <dfn>source types</dfn> of computing
    devices defined by {{PressureSource}}, or there can be multiple [=platform collectors=].
  </p>
  <p>
    From the implementation perspective [=platform collector=] can be treated as a software proxy for the
    corresponding hardware counters. It is possible to have multiple [=platform collector=] simultaneously
    interacting with the same underlying hardware if the underlying platform supports it.
  </p>
  <p>
    In simple cases, a [=platform collector=] represents individual hardware counters, but if the provided
    counter readings are a product of data fusion performed in software, the [=platform collector=]
    represents the results of the data fusion process. This may happen in user space or in kernel space.
  </p>
  <p>
    As collecting telemetry data often means polling hardware counters, it is not a free operation and thus,
    it should not happen if there are no one observing the data. See [[[#life-cycle]]] for more information.
  </p>
  <p>
    A [=platform collector=] samples data at a specific rate. A [=user agent=] may modify this rate
    (if possible) for privacy reasons, or ignore and fuse certain readings.
  </p>
</section>

<section>
  <h3>
    User notifications
  </h3>
  <p>
    It is RECOMMENDED that a [=user agent=] show some form of user-visible
    notification that informs the user when a pressure observer is active,
    as well as provides the user with the means to block the ongoing operation,
    or simply dismiss the notification.
  </p>
</section>

<section>
  <h3>
    Policy control
  </h3>
  <p>
    The Compute Pressure API defines a [=policy-controlled feature=]
    identified by the token "compute-pressure".
    Its [=policy-controlled feature/default allowlist=] is `["self"]`.
  </p>
  <aside class="note">
    <p>
      The [=policy-controlled feature/default allowlist=] of `["self"]` allows usage in
      same-origin nested frames but prevents third-party content from using
      the feature.
    </p>
    <p>
      Third-party usage can be selectively enabled by adding
      `allow="compute-pressure"` attribute to the frame container element:
    </p>
    <pre class="example html" title=
    "Enabling compute pressure on remote content">
      &lt;iframe src="https://third-party.com" allow="compute-pressure"/&gt;&lt;/iframe&gt;
    </pre>
    <p>
      Alternatively, the Compute Pressure API can be disabled completely by
      specifying the permissions policy in a HTTP response header:
    </p>
    <pre class="example http" title="Feature Policy over HTTP">
      Permissions-Policy: {"compute-pressure": []}
    </pre>
    <p>
      See [[[PERMISSIONS-POLICY]]] for more details.
    </p>
  </aside>
</section>

<section>
  <h3>
    Internal Slot Definitions
  </h3>
  <p>
    Each [=global object=] has:
    <ul>
      <li>
        a <dfn>current pressure state</dfn> (a string), initialized to the empty string.
      </li>
      <li>
        a <dfn>pressure observer task queued</dfn> (a boolean), which is initially false.
      </li>
      <li>
        a <dfn>registered observer list</dfn> per supported [=source type=], which is initially empty.
      </li>
      <li>
        a reference to an underlying <dfn>platform collector</dfn> as detailed in [[[#platform-primitives]]].
      </li>
    </ul>
    A <dfn>registered observer</dfn> consists of an <dfn>observer</dfn> (a {{PressureObserver}} object).
  </p>
  <p>
    The [=user agent=] additionally has a <dfn>max queued records</dfn> integer, which
    is set to an [=implementation-defined=] value, greater than 0.
  </p>
  <p>
    A constructed {{PressureObserver}} object has the following internal slots:
  </p>
  <ul data-dfn-for="PressureObserver">
    <li>
      a <dfn>[[\Callback]]</dfn> of type {{PressureUpdateCallback}} set on creation.
    </li>
    <li>
      a <dfn>[[\SampleRate]]</dfn> double set on creation.
    </li>
    <li>
      a <dfn>[[\PendingObservePromises]]</dfn> [=list=] of zero or more source-promise [=tuples=], initially empty,
      where source holds a {{PressureSource}} string and promise holds a {{Promise}} object.
    </li>
    <li>
      a <dfn>[[\QueuedRecords]]</dfn> [=queue=] of zero or more {{PressureRecord}}
      objects, which is initially empty.
    </li>
    <li>
      a <dfn>[[\LastRecordMap]]</dfn> [=ordered map=], [=map/keyed=] on a {{PressureSource}},
      representing the [=source type=] to which the last record belongs.
      The [=ordered map=]'s [=map/value=] is a {{PressureRecord}}.
    </li>
  </ul>
  <p>
    For the [=rate obfuscation=] mitigation the constructed {{PressureObserver}} object additionally
    has the following internal slots:
  </p>
  <ul data-dfn-for="PressureObserver">
    <li>
      an <dfn>[[\ObservationWindow]]</dfn> integer set as part of the [=reset observation window=] steps.
    </li>
    <li>
      a <dfn>[[\MaxChangesThreshold]]</dfn> integer set as part of the [=reset observation window=] steps.
    </li>
    <li>
      a <dfn>[[\PenaltyDuration]]</dfn> integer set as part of the [=reset observation window=] steps.
    </li>
    <li>
      a <dfn>[[\ChangesCountMap]]</dfn> [=ordered map=], [=map/keyed=] on a {{PressureSource}},
      representing the [=source type=] that triggered transition to the [=current pressure state=].
      The [=ordered map=]'s [=map/value=] is an integer representing the number of state changes in the
      current observation window timeframe.
    </li>
    <li>
      a <dfn>[[\AfterPenaltyRecordMap]]</dfn> [=ordered map=], [=map/keyed=] on a {{PressureSource}},
      representing the [=source type=] of the last {{PressureRecord}}.
      The [=ordered map=]'s [=map/value=] is a {{PressureRecord}}.
    </li>
  </ul>
</section>

<section> <h2>Pressure States</h2>
  <p>
    <dfn>Pressure states</dfn> represents the minimal set of useful states that allows websites
    to react to changes in compute and system pressure with minimal degration in quality or service,
    or user experience.
  </p>
  <pre class="idl">
    enum PressureState { "nominal", "fair", "serious", "critical" };
  </pre>
  <p>
    The <dfn>PressureState</dfn> enum represents the [=pressure state=] with the following states:
  </p>
  <p>
    <ul class="pressure-states">
      <li>
        {{PressureState/"nominal"}}: The conditions of the target device are at an acceptable level with no noticeable
        adverse effects on the user.
      </li>
      <li>
        {{PressureState/"fair"}}: Target device pressure, temperature and/or energy usage are slightly elevated, potentially
        resulting in reduced battery-life, as well as fans (or systems with fans) becoming active and audible.
        Apart from that the target device is running flawlessly and can take on additional work.
      </li>
      <li>
        {{PressureState/"serious"}}: Target device pressure, temperature and/or energy usage is consistently highly elevated.
        The system may be throttling as a countermeasure to reduce thermals.
      </li>
      <li>
        {{PressureState/"critical"}}: The temperature of the target device or system is significantly elevated and it requires
        cooling down to avoid any potential issues.
      </li>
    </ul>
  </p>
</section>

<section> <h2>Contributing Factors</h2>
  <p>
    <dfn>Contributing factors</dfn> represent the underlying hardware metrics contributing to the [=current pressure state=]
    and can be [=implementation-defined=].
  </p>
  <p>
    The <dfn>adjusted pressure state</dfn> is a [=pressure state=] determined by an [=implementation-defined=]
    algorithm that takes as input [=source type=] and any other [=implementation-defined=] data from
    [=contributing factors=]. This algorithm MUST not be deterministic to ensure [=break calibration=] mitigation effectiveness.
  </p>
  <p>
    The <dfn>change in contributing factors is substantial</dfn> steps are as follows:
    <ol>
      <li>
        If [=implementation-defined=] low-level hardware metrics that contribute to the
        [=current pressure state=] drop below or exceed an, per metric,
        [=implementation-defined=] threshold
        for the [=current pressure state=], return true.
      </li>
      <li>
        Return false.
      </li>
    </ol>
    <aside class="note">
      <p>
        The [=change in contributing factors is substantial=] algorithm allows [=user agents=] to avoid flip-
        flopping between states in certain circumstances. For example, a state might otherwise change too rapidly
        in response to a certain system metric that fluctuates around a boundary condition that triggers a state
        change.
     </p>
      <p>
        This specification does not define the precise algorithm
        to allow implementations optimize this algorithm to match the underlying hardware platform's behavior.
        One possible implementation of this algorithm is to use a
        <a href="https://en.wikipedia.org/wiki/Preisach_model_of_hysteresis#Nonideal_relay">nonideal relay</a>
        as a model and identify appropriate lower threshold &#945; and upper threshold &#946; for each
        [=pressure state=] taking special characteristics of each contributing factors into consideration.
      </p>
    </aside>
  </p>
</section>

<section> <h2>Pressure Observer</h2>
The Compute Pressure API enables developers to understand the pressure
of system resources such as the CPU.

<section data-dfn-for="PressureObserverCallback">
  <h3>The <a>PressureUpdateCallback</a> callback</h3>
  <pre class="idl">
    callback PressureUpdateCallback = undefined (
      sequence&lt;PressureRecord&gt; changes,
      PressureObserver observer
    );
  </pre>
  This callback will be invoked when the [=pressure state=] changes.
</section>

<section  data-dfn-for="PressureObserver"> <h2>The <a>PressureObserver</a> object</h2>
  <p>
    The {{PressureObserver}} can be used to observe changes in the [=pressure states=].
  </p>
  <pre class="idl">
    [Exposed=(DedicatedWorker,SharedWorker,Window), SecureContext]
    interface PressureObserver {
      constructor(PressureUpdateCallback callback, optional PressureObserverOptions options = {});

      Promise&lt;undefined&gt; observe(PressureSource source);
      undefined unobserve(PressureSource source);
      undefined disconnect();
      sequence&lt;PressureRecord&gt; takeRecords();

      [SameObject] static readonly attribute FrozenArray&lt;PressureSource&gt; supportedSources;
    };
  </pre>

  <p>The <dfn>PressureObserver</dfn> interface represents a {{PressureObserver}}.</p>

  <section>
    <h3>The <dfn>constructor()</dfn> method</h3>
    <p>
      The `new` {{PressureObserver(callback, options)}} constructor steps are:
      <ol class="algorithm">
        <li>
          Set |this|.{{PressureObserver/[[Callback]]}} to |callback:PressureUpdateCallback|.
        </li>
        <li>
          If |options|["sampleRate"] is less than or equal to 0, throw a {{RangeError}}.
        </li>
        <li>
          Set |this:PressureObserver|.{{PressureObserver/[[SampleRate]]}} to |options|["sampleRate"].
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>observe()</dfn> method</h3>
    <p>
      The {{PressureObserver/observe(source)}} method steps are:
      <ol class="algorithm">
        <li>
          Let |document:Document| be [=this=]'s [=relevant settings
          object=]'s [=associated Document=].
        </li>
        <li>
          If |document| is not null and is not [=allowed to use=] the [=policy-controlled
          feature=] token "compute-pressure", return [=a promise rejected with=] {{NotAllowedError}}.
        <aside class="issue">
          <a href="https://github.com/wicg/compute-pressure/issues/110">
            Permission policy doesn't support workers yet #110
          </a>
        </aside>
        </li>
        <li>
          Let |promise:Promise| be [=a new promise=].
        </li>
        <li>
          Let |pendingPromiseTuple| be (|source|, |promise|).
        </li>
        <li>
          [=list/Append=] |pendingPromiseTuple| to [=this=].{{PressureObserver/[[PendingObservePromises]]}}.
        </li>
        <li>
          [=promise/React=] to |promise|:
          <ul>
            <li>
              If |promise| was [=resolved|fulfilled=] or [=rejected=], then:
              <ol>
                <li>
                  [=list/Remove=] |tuple| from [=this=].{{PressureObserver/[[PendingObservePromises]]}}.
                </li>
              </ol>
            </li>
          </ul>
        </li>
        <li>
          Run the following steps [=in parallel=]:
          <ol>
            <li>
              If |source:PressureSource| is not a [=supported source type=],
              [=queue a global task=] on the [=PressureObserver task source=]
              given |document|'s [=relevant global object=] |relevantGlobal|
              to reject |promise| {{NotSupportedError}} and abort these steps.
            </li>
            <li>
              Activate [=data delivery=] of |source| data to |relevantGlobal|.
            </li>
            <li>
              [=Queue a global task=] on the [=PressureObserver task source=] given |document|'s
              [=relevant global object=] |relevantGlobal| to run these steps:
              <ol>
                <li>
                  If |promise| was rejected, run the following substeps:
                  <ol>
                    <li>
                      If |relevantGlobal|'s [=registered observer list=] for |source| is [=list/empty=],
                      deactivate [=data delivery=] of |source| data to |relevantGlobal|.
                    </li>
                    <li>
                      Return.
                    </li>
                  </ol>
                </li>
                <li>
                  [=list/Append=] a new [=registered observer=] whose [=observer=] is [=this=]
                  to |relevantGlobal|'s [=registered observer list=] for |source|.
                </li>
                <li>
                  Resolve |promise|.
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          Return |promise|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>unobserve()</dfn> method</h3>
    <p>
      The {{PressureObserver/unobserve(source)}} method steps are:
      <ol class="algorithm">
        <li>
          If |source:PressureSource| is not a [=supported source type=], throw {{"NotSupportedError"}}.
        </li>
        <li>
          [=list/Remove=] from |this|.{{PressureObserver/[[QueuedRecords]]}} all
          |records| associated with |source|.
        </li>
        <li>
          [=map/Remove=] |this|.{{PressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          [=map/Remove=] |this|.{{PressureObserver/[[AfterPenaltyRecordMap]]}}[|source|].
        </li>
        <li>
          [=list/For each=] (|promiseSource|, |pendingPromise|) of [=this=].{{PressureObserver/[[PendingObservePromises]]}},
          if |source| is equal to |promiseSource|, [=reject=] |pendingPromise| with an {{AbortError}}.
        </li>
        <li>
          Let |relevantGlobal| be [=this=]'s [=relevant global object=].
        </li>
        <li>
          Remove any [=registered observer=] from |relevantGlobal|'s [=registered observer list=] for
          |source| for which [=this=] is the [=registered observer=].
        </li>
        <li>
          If the above [=registered observer list=] is [=list/empty=],
          deactivate [=data delivery=] of |source| data to |relevantGlobal|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>disconnect()</dfn> method</h3>
    <p>
      The {{PressureObserver/disconnect()}} method steps are:
      <ol class="algorithm">
        <li>
          [=list/Empty=] |observer|.{{PressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          [=map/Clear=] |this|.{{PressureObserver/[[LastRecordMap]]}}.
        </li>
        <li>
          [=map/Clear=] |this|.{{PressureObserver/[[AfterPenaltyRecordMap]]}}.
        </li>
        <li>
          [=list/For each=] (|promiseSource|, |pendingPromise|) of [=this=].{{PressureObserver/[[PendingObservePromises]]}},
          [=reject=] |pendingPromise| with an {{AbortError}}.
        </li>
        <li>
          Let |relevantGlobal| be [=this=]'s [=relevant global object=].
        </li>
        <li>
          Remove any [=registered observer=] from |relevantGlobal|'s' [=registered observer list=] for
          all supported [=source types=] for which [=this=] is the [=observer=].
        </li>
        <li>
          If the above [=registered observer list=] is [=list/empty=],
          deactivate [=data delivery=] of |source| data to |relevantGlobal|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>takeRecords()</dfn> method</h3>
    <aside class="note">
      <p>
        A common use case for this is to immediately fetch all pending state change records
        immediately prior to disconnecting the observer, so that any pending state changes
        can be processed when shutting down the observer.
      </p>
      <p>
        Another use case is the ability to receive any pending, already-generated states
        changes without waiting for the callbacks to be invoked. Callbacks are invoked from
        a task queue as part of the event loop cycle, so this allows for conferring the
        current state outside of the event loop cycle.
      </p>
    </aside>
    <p>
      The {{PressureObserver/takeRecords()}} method steps are:
      <ol class="algorithm">
        <li>
          Let |records| be a [=list/clone=] of |observer|.{{PressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          [=list/Empty=] |observer|.{{PressureObserver/[[QueuedRecords]]}}.
        </li>
        <li>
          Return |records|.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>The <dfn>supportedSources</dfn> attribute</h3>
    <p>
      The {{PressureObserver/supportedSources}} attribute is informing on the [=supported source type=] by the [=platform collector=].
    </p>
    <p>
      The {{PressureObserver/supportedSources}} getter steps are:
      <ol class="algorithm">
        <li>
          Let |sources| be a [=list=] of |source:PressureSource|.
        </li>
        <li>
          Return |observer|'s frozen array of supported [=source types=].
        </li>
      </ol>
    </p>
    <aside class="note">
      <p>
        This attribute allows web developers to easily know which [=source types=] are supported by the user agent.
      </p>
    </aside>
  </section>
</section>

<section data-dfn-for="PressureRecord">
  <h3>The <dfn>PressureRecord</dfn> interface</h3>
  <pre class="idl">
    [Exposed=(DedicatedWorker,SharedWorker,Window), SecureContext]
    interface PressureRecord {
      readonly attribute PressureSource source;
      readonly attribute PressureState state;
      readonly attribute DOMHighResTimeStamp time;
      [Default] object toJSON();
    };
  </pre>
  <p>
    A constructed  {{PressureRecord}} object has the following internal slots:
  </p>
  <ul data-dfn-for="PressureRecord">
    <li>
      a <dfn>[[\Source]]</dfn> value of type {{PressureSource}}, which represents the current [=source type=].
    </li>
    <li>
      a <dfn>[[\State]]</dfn> value of type {{PressureState}}, which represents the [=current pressure state=].
    </li>
    <li>
      a <dfn>[[\Time]]</dfn> value of type {{DOMHighResTimeStamp}},
      which corresponds to the
      time the data was obtained from the system, relative to the [=environment settings object/time origin=] of the global object associated with
      the {{PressureObserver}} instance that generated the notification.
    </li>
  </ul>
  <section>
    <h3>The <dfn>source</dfn> attribute</h3>
    <p>
      The {{PressureRecord/source}} [=getter steps=] are to return its {{PressureRecord/[[Source]]}} internal slot.
    </p>
  </section>
  <section>
    <h3>The <dfn>state</dfn> attribute</h3>
    <p>
      The {{PressureRecord/state}} [=getter steps=] are to return its {{PressureRecord/[[State]]}} internal slot.
    </p>
  </section>
  <section>
    <h3>The <dfn>time</dfn> attribute</h3>
    <p>
      The {{PressureRecord/time}} [=getter steps=] are to return its {{PressureRecord/[[Time]]}} internal slot.
    </p>
  </section>
  <section>
    <h3>The <dfn>toJSON</dfn> member</h3>
    <p>
      When {{PressureRecord.toJSON}} is called, run [[[WebIDL]]]'s [=default toJSON steps=].
    </p>
  </section>
</section>

<section data-dfn-for="PressureObserverOptions">
  <h3>The <dfn>PressureObserverOptions</dfn> dictionary</h3>
  <pre class="idl">
    dictionary PressureObserverOptions {
      double sampleRate = 1.0;
    };
  </pre>
  <section>
    <h3>The <dfn>sampleRate</dfn> member</h3>
    <p>
      The {{PressureObserverOptions/sampleRate}} member represents the <dfn>requested sampling
      rate</dfn> expressed in Hz, ie. it represents the number of samples requested to be obtained
      from the hardware per second. The [=reporting rate=] will never exceed the [=requested sampling rate=].
    </p>
    <aside class="note">
      <p>
        For slow sampling rates (less than 1hz), it is common to use seconds and talk about
        period instead of rate. Fortunately, it is easy to convert between the two, as hertz
        is rotations per second. If you want to request a sampling rate of 10 seconds, then
        just use the value of 0.1.
      </p>
      <p>
        A [=user agent=] might not be able to respect the requested sampling rate. For more information
        consult [[[#sampling-and-reporting-rate]]].
      </p>
    </aside>
  </section>
</section>

<section id="life-cycle">
  <h3>Life-cycle and garbage collection</h3>
  <p>
    Each [=global object=] has a
    strong reference to [=registered observers=] in their [=registered observer list=]
    (one per source).
  </p>
  <aside class="note">
    <p>
      A {{PressureObserver}} is observing a |source:PressureSource| if it
      exists in the [=registered observer list=], modified by invocations of
      {{PressureObserver/observe()}},
      {{PressureObserver/unobserve()}}
      and {{PressureObserver/disconnect()}}.
    </p>
    <p>
      This means that a {{PressureObserver}} object |observer:PressureObserver| will
      remain alive (thus not be garbage collection) until both of these conditions hold:
      <ul>
        <li>
          There are no scripting references to the |observer|.
        </li>
        <li>
          The |observer| is not observing any |source|.
        </li>
      </ul>
    </p>
    <p>
      [[[#cb-observer-example]]] contains an example of how to use the
      {{PressureObserver/disconnect()}} (or any other {{PressureObserver}}
      method) from the observer callback.
    </p>
  </aside>
</section>

<section id="processing-model">
  <h3>Processing Model</h3>
  <p>
    This section outlines the steps the user agent must take when implementing the specification.
  </p>
  <section>
    <h3>Supporting algorithms</h3>
    <p>
      The <dfn>reset observation window</dfn> steps given the argument |observer:PressureObserver|, are as follows:
      <ul>
        <li>
          set |observer|.{{PressureObserver/[[ObservationWindow]]}} to an [=implementation-defined=] randomized integer value in
          milliseconds within an [=implementation-defined=] range.
        </li>
        <li>
          set |observer|.{{PressureObserver/[[MaxChangesThreshold]]}} to an [=implementation-defined=] randomized integer
          value of maximum allowed changes within the |observationWindow| within an [=implementation-defined=] range.
        </li>
        <li>
          set |observer|.{{PressureObserver/[[PenaltyDuration]]}} to an [=implementation-defined=] randomized integer value
          in milliseconds, within an [=implementation-defined=] range.
        </li>
        <li>
          [=list/Empty=] the observer.{{PressureObserver/[[ChangesCountMap]]}} map.
        </li>
      </ul>
      Run the [=reset observation window=] steps and start a timer to re-run the steps when the observer.{{PressureObserver/[[ObservationWindow]]}}
      time has passed, using different randomized values.
    </p>
    <p>
      <aside class="note">
        Readings are available for [=documents=] (incl. [=iframes=] and popup windows) and workers,
        matching the following criteria:
        <ul>
          <li>
            They are [=Document/fully active=] [=documents=], or
            they are <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">active needed workers</a>.
          </li>
          <li>
            Their [=origin=] is [=same origin=] with the [=Node/node document|document=] containing the
            <a href="https://html.spec.whatwg.org/multipage/interaction.html#focused">focused</a> [=node=], or an
            <a href="https://w3c.github.io/picture-in-picture/#initiators-of-active-picture-in-picture-sessions">
            initiator of an active Picture-in-Picture session</a>, or the browsing [=context is capturing=],
            including microphone, camera and display.
          </li>
        </ul>
      </aside>
      The <dfn>passes privacy test</dfn> steps given the argument |observer:PressureObserver| and
      its [=relevant global object=] |relevantGlobal|, are as follows:
      <ol>
        <li>
          If |relevantGlobal| is a {{WorkerGlobalScope}} object:
          <ol>
            <li>
              If |relevantGlobal|'s relevant worker is not a <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
              active needed worker</a>, return false.
            </li>
            <li>
              Otherwise, return true.
            </li>
          </ol>
        </li>
        <li>
          If |relevantGlobal| is a {{Window}} object:
          <ol>
            <li>
            If |relevantGlobal|'s [=associated document=] is not [=Document/fully active=], return false.
            </li>
            <li>
              [=list/For each=] |origin| in
              <a href="https://w3c.github.io/picture-in-picture/#initiators-of-active-picture-in-picture-sessions">
                initiators of active Picture-in-Picture sessions</a>:
              <ol>
                <li>
                  If |relevantGlobal|'s [=relevant settings object=]'s [=origin=] is [=same origin=] with |origin|, return true.
                </li>
              </ol>
            </li>
            <li>
              If |relevantGlobal|'s [=browsing context=] is [=context is capturing|capturing=], return true.
            </li>
            <li>
              Let |topLevelBC| be |relevantGlobal|'s [=browsing context=]'s [=top-level browsing context=].
            </li>
            <li>
              If |topLevelBC| does not have [=top-level traversable/system focus=], return false.
            </li>
            <li>
              Let |focusedDocument| be the |topLevelBC|'s
              <a href="https://html.spec.whatwg.org/multipage/interaction.html#currently-focused-area-of-a-top-level-browsing-context">
                currently focused area</a>'s [=Node/node document=].
            </li>
            <li>
              If |relevantGlobal|'s [=relevant settings object=]'s [=origin=] is [=same origin=] with
              |focusedDocument|'s [=origin=], return true.
            </li>
            <li>
              Otherwise, return false.
            </li>
          </ol>
        </li>
      </ol>
      <aside class="note">
        As there might be multiple observers, each with a different [=requested sampling rate=], the underlying
        [=platform collector=] will need to use a [=sampling rate=] that fulfills all these requirements. This also
        means that not every data sample from the [=platform collector=] needs to be delivered to each active
        observer.
      </aside>
      The <dfn>passes rate test</dfn> steps given the argument |observer:PressureObserver|,
      |source:PressureSource| and |timestamp:DOMHighResTimeStamp|, are as follows:
      <ol>
        <li>
          If |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|] does not [=map/exist=], return true.
        </li>
        <li>
          Let |record:PressureRecord| be |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          Let |sampleRate| be |observer|.{{PressureObserver/[[SampleRate]]}}.
        </li>
        <li>
          Let |timeDeltaMilliseconds:DOMHighResTimeStamp| = |timestamp| - |record|.{{PressureRecord/[[Time]]}}.
        </li>
        <li>
          Let |intervalSeconds| = 1 / |sampleRate|.
        </li>
        <li>
          If (|timeDeltaMilliseconds| / 1000) &ge; |intervalSeconds|, return true, otherwise return false.
        </li>
      </ol>
      The <dfn>has change in data</dfn> steps given the argument |observer:PressureObserver|, |source:PressureSource|,
      |state:PressureState|, are as follows:
      <ol>
        <li>
          If |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|] does not [=map/exist=], return true.
        </li>
        <li>
          Let |record:PressureRecord| be |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|].
        </li>
        <li>
          If |record|.{{PressureRecord/[[State]]}} is not equal to |state| and [=change in contributing factors is substantial=]
          returns true, return true.
        </li>
        <li>
          Return false.
        </li>
      </ol>
      The <dfn>passes rate obfuscation test</dfn> steps given the argument |observer:PressureObserver|,
      |source:PressureSource|, are as follows:
      <ol>
        <li>
          Increment observer.{{PressureObserver/[[ChangesCountMap]]}}[|source|].
        </li>
        <li>
          Return observer.{{PressureObserver/[[ChangesCountMap]]}}[|source|]
          &le; observer.{{PressureObserver/[[MaxChangesThreshold]]}}.
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>Data delivery</h3>
    <p>
      [=Data delivery=] from a [=platform collector=] can be activate and deactivated in an
      [=implementation-defined=] manner per [=source type=] and [=global object=].
    </p>
    <aside class="note">
      It is recommended that the [=platform collector=] suspends low-level data polling
      when there is no active [=data delivery=] to any {{PressureObserver}} [=relevant global object=].
    </aside>
    <p>
      The <dfn>data delivery</dfn> steps that are run when
      an [=implementation-defined=] |data| sample of [=source type=] |source:PressureSource| is
      obtained from [=global object=] |relevantGlobal|'s [=platform collector=],
      are as follows:
      <ol>
        <li>
          Let |source:PressureSource| be the [=source type=] of the |data| sample.
        </li>
        <li>
          Let |state:PressureState| be an [=adjusted pressure state=] given |data| and |source|.
        </li>
        <li>
          Let |timestamp:DOMHighResTimeStamp| be a timestamp representing the time the |data| was
          obtained from the |relevantGlobal|'s [=platform collector=].
        <aside class="note">
          The |data| sample and mapping between |data| sample, and [=pressure states=],
          is [=implementation-defined=] and may use many different metrics. For instance,
          for CPU, it might consider processor frequency and utilization, as well
          as thermal conditions.
        </aside>
        </li>
        <li>
          [=list/For each=] |observer:PressureObserver| in |relevantGlobal|'s
          [=registered observer list=] for |source|:
          <ol>
            <li>
              If running [=passes privacy test=] with |observer|
              returns false, [=iteration/continue=].
            </li>
            <li>
              If running [=passes rate test=] with |observer|, |source| and |timestamp|
              returns false, [=iteration/continue=].
            </li>
            <li>
              If running [=has change in data=] with |observer|, |source| and |state|
              returns false, [=iteration/continue=].
            </li>
            <li>
              Let |record:PressureRecord| be a new {{PressureRecord}} object with its
              {{PressureRecord/[[Source]]}} set to |source|,
              {{PressureRecord/[[State]]}} set to |state|
              and {{PressureRecord/[[Time]]}} set to |timestamp|.
            </li>
            <li>
              If |observer|.{{PressureObserver/[[AfterPenaltyRecordMap]]}}[source] [=map/exists=]:
              <ol>
                <li>
                  Set |observer|.{{PressureObserver/[[AfterPenaltyRecordMap]]}}[|source|] to |record|.
                </li>
                <li>
                  [=iteration/Continue=].
                </li>
              </ol>
            </li>
            <li>
              If running [=passes rate obfuscation test=] with |observer| and |source| returns false:
              <ol>
                <li>
                  Set |observer|.{{PressureObserver/[[AfterPenaltyRecordMap]]}}[|source|] to |record|.
                </li>
                <li>
                  Set |observer|.{{PressureObserver/[[ChangesCountMap]]}}[|source|] to 0.
                </li>
                <li>
                  Create timer of |observer|.{{PressureObserver/[[PenaltyDuration]]}} duration with the following callback:
                  <ol>
                    <li>
                      If |observer|.{{PressureObserver/[[AfterPenaltyRecordMap]]}}[source] [=map/exists=]:
                      <ol>
                        <li>
                          Let |record| be |observer|.{{PressureObserver/[[AfterPenaltyRecordMap]]}}[|source|].
                        </li>
                        <li>
                          [=map/Remove=] |observer|.{{PressureObserver/[[AfterPenaltyRecordMap]]}}[|source|].
                        </li>
                        <li>
                          Run [=queue a record=] with |observer|, |source|, |record|.
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li>
                  [=iteration/Continue=].
                </li>
              </ol>
            </li>
            <li>
              Run [=queue a record=] with |observer|, |source|, |record|.
            </li>
          </ol>
        </li>
      </ol>
    </p>
  </section>
  <section>
    <h3>Queue a PressureRecord</h3>
    <p>
      To <dfn>queue a record</dfn> given the arguments |observer:PressureObserver|,
      |source:PressureSource|, |record:PressureRecord|,
      run these steps:
    </p>
    <ol class="algorithm">
      <li>
        If [=list/size=] of |observer|.{{PressureObserver/[[QueuedRecords]]}} is greater than
        [=max queued records=], then [=list/remove=] the first [=list/item=].
      <li>
        [=list/Append=] |record| to |observer|.{{PressureObserver/[[QueuedRecords]]}}.
      </li>
      <li>
        Set |observer|.{{PressureObserver/[[LastRecordMap]]}}[|source|] to |record|.
      </li>
      <li>
        [=Queue a pressure observer task=] with |observer|'s [=relevant global object=].
      </li>
    </ol>
  </section>
  <section>
    <h3>Queue a Pressure Observer Task</h3>
    <p>
      The <dfn>PressureObserver task source</dfn> is a [=task source=] used for scheduling tasks to [[[#notify-observers]]].
    </p>
    <p>
      To <dfn>queue a pressure observer task</dfn> given |relevantGlobal| as input, run these steps:
    </p>
    <ol class="algorithm">
      <li>
        If the |relevantGlobal|'s [=pressure observer task queued=] is true, then return.
      </li>
      <li>
        Set the |relevantGlobal|'s [=pressure observer task queued=] to true.
      </li>
      <li>
        [=Queue a global task=] on [=PressureObserver task source=] with |relevantGlobal| to [=notify pressure observers=].
      </li>
    </ol>
  </section>
  <section id="notify-observers">
    <h3>Notify Pressure Observers</h3>
    <p>
      To <dfn>notify pressure observers</dfn> given |relevantGlobal| as input, run these steps:
    </p>
    <ol class="algorithm">
      <li>
        Set |relevantGlobal|'s [=pressure observer task queued=] to false.
      </li>
      <li>
        Let |notifySet| be a new [=set=] of all [=observers=] in
        |relevantGlobal|’s [=registered observer lists=].
      </li>
      <li>
        [=list/For each=] |observer:PressureObserver| of |notifySet|:
        <ol>
          <li>
            Let |records| be a [=list/clone=] of |observer|.{{PressureObserver/[[QueuedRecords]]}}.
          </li>
          <li>
            [=list/Empty=] |observer|.{{PressureObserver/[[QueuedRecords]]}}.
          </li>
          <li>
            If |records| is not [=list/empty=], then invoke |observer|.{{PressureObserver/[[Callback]]}}
            with |records| and |observer|. If this throws an exception, catch it, and [=report the exception=].
          </li>
        </ol>
      </li>
    </ol>
  </section>
  <section>
    <h3>Handling change of fully active</h3>
    <p>
      When a {{Document}} |document| is no longer [=Document/fully active=],
      deactivate [=data delivery=] of data of all [=supported source types=] to |document|'s [=relevant global object=].
    </p>
    <p>
      When a worker with associated {{WorkerGlobalScope}} |relevantGlobal| is no longer
      an <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
      active needed workers</a>,
      deactivate [=data delivery=] of data of all [=supported source types=] to |relevantGlobal|.
    </p>
    <p>
      When a {{Document}} |document| becomes [=Document/fully active=],
      for each non-[=list/empty=] [=registered observer list=] associated the [=source type=] |source|,
      activate [=data delivery=] of |source| data to |document|'s [=relevant global object=].
    </p>
    <p>
      When a worker with associated {{WorkerGlobalScope}} |relevantGlobal| becomes
      an <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
      active needed workers</a>,
      for each non-[=list/empty=] [=registered observer list=] associated the [=source type=] |source|,
      activate [=data delivery=] of |source| data to |document|'s [=relevant global object=].
    </p>
    <aside class="note">
      When a document is no longer [=Document/fully active=] (or associated workers no longer
      <a href="https://html.spec.whatwg.org/multipage/workers.html#active-needed-worker">
      active needed workers</a>), like when
      entering the back/forward cache, or "BFCache" for short, then no events are send to the pressure observers
      (see [=passes privacy test=])
      in accordance with <a href="https://www.w3.org/TR/design-principles/#listen-fully-active">
      Web Platform Design Principles: Listen for changes to fully active status</a>. This means that the
      system can safely deactivate [=data delivery=] from the associated [=platform collector=],
      but also that it needs to be re-activated when the opposite happens.
    </aside>
  </section>

  <section id="unload-observers">
    <h3>Handle unloading document and closing of workers</h3>
    <p>
      When a worker with associated {{WorkerGlobalScope}} |relevantGlobal|,
      once |relevantGlobal|'s [=WorkerGlobalScope/closing=] flag is set to true,
      deactivate [=data delivery=] for all [=supported source types=] to |relevantGlobal|.
    </p>
    <p>
      As one of the [=unloading document cleanup steps=] given {{Document}} |document|,
      deactivate [=data delivery=] for all [=supported source types=] to |document|'s [=relevant global object=].
    </p>
  </section>
</section>
</section> <!-- Pressure Observer -->

<section>
  <h2>
    Security and privacy considerations
  </h2>

  <section>
    <h3>Types of privacy and security threats</h3>
    <div class="note">
      The Working Group will list any known attack vectors, both theoretical and real-world,
      in this section.
    </div>
    <h4>Timing attacks</h4>
    <p>
      It may be possible to identify users across non-[=same origin=] sites if unique
      or very precise values can be accessed at the same time by sites not sharing
      origin.

      This attack is mitigated by [[[#data-minimization]]], [[[#rate-limiting-change-notifications]]],
      and [[[#same-origin-restriction]]].
    </p>
    <h4>Cross-site covert channel</h4>
    <p>
      In computer security a covert channel creates a capability to transfer information between processes
      that are not supposed to be allowed to communicate. In modern multi-process web engines in the generic
      case each window or tab resides in its own process (documents that have the [=same origin=] or sites that
      have the [=same site=] typically share the same process). Using this API it may be possible to create a
      cross-site covert channel C where a site A on one tab first broadcasts to the channel C after having
      manipulated the state of the CPU. Next a site B (that is not same site with site A) on another tab reads
      the broadcasted data from the channel C by using this API to learn when the state of the CPU has changed.
      This process is repeated as long as the scripts run on both the sites A and B.
    </p>
    <p>
      This attack is mitigated by [[[#rate-limiting-change-notifications]]], [[[#rate-obfuscation]]] and
      [[[#break-calibration]]]. Implementers are advised to consider all these mitigations for long-running scripts.
    </p>
    <div class="note">
      The longer the scripts run the more information can be transmitted using the proposed cross-site covert channel.
      For example, if a user is on a video conferencing site and another long-running site that allows for more
      information to be transferred compared to a regular browsing scenario. On the other hand, a workload such as
      a video conferencing session will typically exert sustained pressure on the CPU that makes it harder to
      manipulate the pressure state in a predictive manner.
    </div>

  </section>

  <section>
    <h3>Mitigation strategies</h3>

    <div class="note">
      This section gives a high-level view into mitigation strategies applicable to this specification.
      The normative definitions of these mitigations are integrated into the respective algorithms of this specification.
      Implementers are advised to consider the
      <a href="https://www.w3.org/2001/tag/doc/private-browsing-modes/#features-supporting-private-browsing">TAG guidance
      on private browsing modes</a> when implementing the mitigations defined in this specification.
    </div>

    <h4>Data minimization</h4>
    <p>
      This specification adheres to the generic
      <a href="https://www.w3.org/TR/privacy-principles/#data-minimization">data minimization</a> principles
      to limit exposure of data related to low-level details of the underlying platform to the minimum required to
      address its high-value use cases. This includes consideration for limiting exposure of
      <a href="https://w3ctag.github.io/design-principles/#device-ids">identifying information about devices</a>.
    </p>
    <p>
      The specific application of data minimization principles in the context of this specification
      are discussed in [[[#rate-limiting-change-notifications]]] and [[[#same-origin-restriction]]].
      <section>
        <h4>Rate-limiting change notifications</h4>
        <p>
          By rate-limiting the delivery of the pressure state information we remove the
          attacker's ability to observe the precise time when a value transitions between two states.
        </p>
        <p>
          More precisely, once the pressure observer is activated, it will be
          called once with initial values, and then is called when the values change.
          The subsequent calls will be rate-limited. When the callback is
          called, the most recent value is reported.
        </p>
        <p>
          The specification will recommend a rate limit of at most one call per second
          for the active window, and one call per 10 seconds for all other windows. We
          will also recommend that the call timings are jittered across origins.
        </p>
        <p>
          These measures benefit the user's privacy, by reducing the risk of
          identifying a device across multiple origins. The rate-limiting also benefits
          the user's security, by making it difficult to use this API for timing attacks.
          Last, rate-limiting change callbacks places an upper bound on the performance
          overhead of this API.
        </p>
        <p>
          Rate limiting can be implemented in the user agent, but it might also be
          possible to simply change the polling/sampling rate of the underlying hardware
          counters, if not accessed via a higher level framework.
        </p>
      </section>
      <section>
        <h4>Rate obfuscation</h4>
        <p>
          The specification requires implementing the <dfn>rate obfuscation</dfn> mitigation
          to keep track of the number of pressure changes over an [=implementation-defined=]
          sliding observation window and
          set a flag if an [=implementation-defined=] threshold for the number of pressure
          changes is exceeded. Similarly, it is also recommended for the implementation to
          observe any abnormal activity such as a high number of pressure state changes
          spanning across multiple states, and set this flag similarly.
        </p>
        <p>
          If this flag is set, the implementation is recommended to give the pressure observer
          a penalty during which it will not be able to inform scripts of changes in its
          pressure state as it normally would. The duration of this penalty is
          [=implementation-defined=] and it is recommended to be randomized.
          When [=notify pressure observers=] resumes operation after the penalty, it only
          reports the latest pressure state and disregards any interim state information
          received from the platform collector during this penalty.
        </p>
      </section>
      <section>
        <h4>Rate obfuscation parameters</h4>
        <p><i>This section is non-normative.</i></p>
        <p>
          Implementers are advised to use:
          <ul>
            <li>
              a range between 300000 milliseconds (5 minutes) and 600000 milliseconds (10 minutes) for |observer|.{{PressureObserver/[[ObservationWindow]]}}.
            </li>
            <li>
              a range in between 50 and 100 changes for |observer|.{{PressureObserver/[[MaxChangesThreshold]]}}.
            </li>
            <li>
              a range in milliseconds between 5000 and 10000 for |observer|.{{PressureObserver/[[PenaltyDuration]]}}.
            </li>
          </ul>
        </p>
      </section>
      <section>
        <h4>Break calibration</h4>
        <p>
          In a calibration process an attacker tries to manipulate the CPU so that this
          API would report a transition into a certain pressure state with the highest
          probability in response to the pressure exerted by the fabricated workload.
          This <dfn>break calibration</dfn> mitigation solution can slow down or prevent this calibration process
          from succeeding by slightly changing at runtime the [=implementation-defined=]
          low-level hardware metrics that contribute to these pressure state transitions.
          Even if the initial calibration would succeed, its results will be invalidated
          at runtime when this mitigation is running continuously. Any attempts to recalibrate
          will similarly be mitigated against.
        </p>
        <aside class="note">
          Modern browsers throttle background tabs using [=implementation-defined=]
          heuristics in order to reduce resource usage. For example, after a period of
          no user interaction a background tab can be throttled that will influence
          the global pressure state of the system. This built-in feature of modern
          browsers further improves the effectiveness of the break calibration
          mitigation.
        </aside>
      </section>
      <section>
        <h4>Break calibration parameters</h4>
        <p><i>This section is non-normative.</i></p>
        <p>
          Implementers are advised to apply the mitigation to a randomized time value within a range
          between 120000 milliseconds (2minutes) and 240000 milliseconds (4 minutes).
      </section>
      <section>
        <h4>Same-origin restriction</h4>
        <p>
          By <em>default</em> data delivery is restricted to documents served from the same-origin as an
          <a href="https://w3c.github.io/picture-in-picture/#initiators-of-active-picture-in-picture-sessions">
          initiator of an active picture-in-picture-session</a>,
          documents [=context is capturing|capturing=]
          or the document with [=top-level traversable/system focus=], if any.
        </p>
        <p>
          The documents qualifying for data delivery, under the above rules, can delegate it to documents in [=child navigables=].
        </p>
        <p>
          The feature can be extended to third-party contexts such as iframes only by a
          <a href="https://www.w3.org/TR/permissions-policy/#permissions-policy-declared-policy">declared policy</a>.
        </p>
      </section>
    </p>
  </section>
</section>
<section id="examples" class="informative">
  <h2>
    Examples
  </h2>
  <pre class="example js" title="How to access observer from callback" id="cb-observer-example">
    const samples = [];

    function pressureChange(records, observer) {
      for (const record of records) {
        samples.push(record.state);

        // We only want 20 samples.
        if (samples.length == 20) {
          observer.disconnect();
          return;
        }
      }
    }

    const observer = new PressureObserver(pressureChange);
    observer.observe("cpu");
  </pre>
  <p>
    In the following example we want to lower the number of concurrent video streams when the
    pressure becomes critical. For the sake of simplicity we only consider this one state.
  </p>
  <p>
    As lowering the amount of streams might not result in exiting the critical state,
    or at least not immediately, we use a strategy where we lower one stream at the time
    every 30 seconds while still in the critical state.
  </p>
  <p>
    We accomplish this by making sure the callback is called at least once every 30 seconds,
    or when the state actually changes. When the state changes we reset the interval timer.
  </p>
  <pre class="example js" title="How to adjust the number of video feeds based on CPU pressure">
    let timerId = -1;
    function pressureChange(records) {
      // Clear timer every time we are called, either by an actual state change,
      // or when called by setTimeout (see below).
      if (timerId > 0) {
        clearTimeout(timerId);
      }

      // When entering critical state, we want to recheck every 30sec if we are
      // still in critical state and if so, further reduce our concurrent streams.
      // For this reason we create a timer for 30 seconds that will call us back
      // with the last result in there were no change.
      const lastRecordArray = [records.at(records.length - 1)];
      timerId = setTimeout(pressureChange.bind(this, lastRecordArray), 30_000);

      for (const record of records) {
        if (record.state == "critical") {
          let streamsCount = getStreamsCount();
          setStreamsCount(streamsCount--);
        }
      }
    }

    const observer = new PressureObserver(pressureChange);
    observer.observe("cpu");
  </pre>
  <p>
    In the following example, we want to demonstrate the usage of {{PressureObserver/takeRecords()}},
    by retrieving the remaining |records| accumulated since the the callback was last
    invoked.
  </p>
  <p>
    It is recommended to do so before {{PressureObserver/disconnect()}},
    otherwise {{PressureObserver/disconnect()}} will clear them and they will be lost forever.
  </p>
  <p>
    For example, we might want to measure the pressure during a benchmarking workload, and thus
    want pressure telemetry for the exact duration of the workload. This means disconnecting all
    observers immediately when the task is completed, and manually requesting any pending pressure
    telemetry up to this point that might not have been delivered yet as part of the event loop cycle.
  </p>
  <pre class="example js" title="How to handle all state changes right up until disconnect">
    function logWorkloadStatistics(records) {
      // do something with records.
    }

    const observer = new PressureObserver(logWorkloadStatistics);
    observer.observe("cpu");

    // Read pending state change records, otherwise they will be cleared
    // when we disconnect.
    const records = observer.takeRecords();
    logWorkloadStatistics(records);

    observer.disconnect();
  </pre>
  <p>
    In the following example, we show how to tell the observer to stop watching a specific
    |source:PressureSource| by invoking {{PressureObserver/unobserve()}}
    with |source|.
  </p>
  <aside class="note">
    The example uses 'gpu', which could be a potential future addition to the specification. It aims to show
    that the API is extentable to support other types of pressure in the future
  </aside>
  <pre class="example js" title="How to tell the observer to stop watching for state changes for a specific source">
    const observer = new PressureObserver(records => { /* do something with records. */ });

    observer.observe("cpu");
    observer.observe("gpu");

    // Callback now gets called whenever the pressure state changes for 'cpu' or 'gpu'.

    observer.unobserve("gpu");

    // Callback now only gets called whenever the pressure state changes for 'cpu'.
  </pre>
  <p>
    In the following example, we show how to tell the observer to stop watching for any
    state changes by calling {{PressureObserver/disconnect()}}. Calling
    {{PressureObserver/disconnect()}} will stop observing all sources observed
    by previous {{PressureObserver/observe()}} calls.
  </p>
  <p>
    Additionally it will clear all pending records collected since the last callback was invoked.
  </p>
  <pre class="example js" title="how to tell the observer to stop watching for any state changes">
    const observer = new PressureObserver(records => { // do something with records. });
    observer.observe("cpu");
    observer.observe("gpu");

    // some time later...

    observer.disconnect();

    // records will be an empty array, because of the previous disconnect().
    const records = observer.takeRecords();
  </pre>
</section>
<section id="conformance">
  <p>
    This specification defines conformance criteria for a single product: a
    <dfn>user agent</dfn> that implements the interfaces that it contains.
  </p>
</section>
<section class="appendix informative" id="acknowledgments"> <h2>Acknowledgments</h2>
  <p>
    Many thanks for valuable feedback and advice from
    Anssi Kostiainen,
    Asaf Yaffe,
    Chen Xing,
    Evan Shrubsole,
    François Beaufort,
    Jan Gora,
    Jesse Barnes,
    Joshua Bell,
    Kamila Hasanbega,
    Matt Menke,
    Moh Haghighat,
    Nicolás Peña Moreno,
    Opal Voravootivat,
    Paul Jensen,
    Peter Djeu,
    Raphael Kubo da Costa,
    Reilly Grant,
    Ulan Degenbaev,
    Victor Miura,
    Wei Wang,
    and
    Zhenyao Mo
  </p>
  <p>
    Thanks to the W3C Privacy Interest Group (PING) and especially Peter Snyder
    for the privacy review, feedback and the proposed cross-site covert channel
    attack and its mitigations. Similarly thanks to Ehsan Toreini for his work on
    the privacy of private browsing and related contributions to this specification.
  </p>
  <p>
    Special thanks to
    Amanda Zhao,
    Fidel Tian,
    Zhiliang Wang
    and others from the Zoom engineering team for the feedback and hands-on experiments
    that have helped improve this API in real-world scenarios.
  </p>
</section>

<section id="idl-index" class="appendix">
  <!-- All the Web IDL will magically appear here -->
</section>
